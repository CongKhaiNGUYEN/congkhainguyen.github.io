---
title: Notes | Basic Static Analysis
author: Zeropio
date: 2022-09-05
categories: [Notes, Malware]
tags: [malware]
permalink: /notes/malware/basic-static-analysis
---

**Basic Static Analysis** is a limited triage approach to the tools and techniques we are using, meaning that we are not running the binary. This is the first step before executing the malware. We will not get any final conclusions without running the malware, but we can get a general idea to what to do next.

# File Hashes

We don’t need to remove the extension added to remove the binary execution, as this is a *Static Analysis*. Using the tools from **Flare VM**, we can get the malware sha256 hash as:

```bash
C:\Users\zeropio\Desktop
λ sha256sum.exe <MALWARE FILE>
	<HASH>
```

And the md5 hash:

```bash
C:\Users\zeropio\Desktop
λ md5sum.exe <MALWARE FILE>
	<HASH>
```

Save both hash. as they can be used for fingerprinting the malware. We can go now to [VirusTotal](https://www.virustotal.com/gui/home/search) and search for both hashes.

# Strings

As you may know computers use strings to identify piece of chars. Composed by each chars and one end chars, which is the null byte (meaning that the string has ended). In malware, if a sample aim to a external resources (as a web), the **.exe** need to call it. This resource is saved as a string in the **.exe**.

If we can see the binary and get the binary, we can guess the usage of it. We can use the `string` command, as Linux, to get all the strings from a binary. Or use the `floss` in the Flame VM, which is a better `string` command.

`floss` output the string formatted, giving us the info directly. We can get even some path to other resources. The usage is as simple as:

```bash
C:\Users\zeropio\Desktop
λ floss <MALWARE FILE>
```

- Keep in mind that these strings can be getting in for trick a reverse engineer.
    
    

{: .prompt-alert}

# Address Table

For this part we need to go to `C:\Users\<YOUR USER>\Desktop\FLARE\Utilities\peview`{: .filepath}. Executing this program with the malware sample:

![Untitled](/assets/img/notes/malware/Untitled.png)

Every executable file start the same way. You can see in the **Value** column, the `MZ` string.

One interesting thing to check is in the **IMAGE_FILE_HEADER**, under the **IMAGE_NT_HEADERS**. Here you can see the **Time Data Stamp**, which tell us the time this binary was compiled. It is not a 100% trustable, but even if the date is change (to some weird date like **1990**), we can know that something has been changed.

![Untitled](/assets/img/notes/malware/Untitled%201.png)

Other folder is the **IMAGE_SECTION_HEADER .text**. There you have the **Virtual Size** and the **Size of Raw Data**. If we take both numbers (they are in hex) and compare both of them. The **Virtual Size** is the binary size when it is running. If the different between them is huge we can guess that this binary can be a **packed binary**.

![Untitled](/assets/img/notes/malware/Untitled%202.png)

## Windows API

The **Windows API** (Application Programming Interface) are a set of functions made to facilitate programmers their code. If they want to make some functions, instead of writing them, they can use the Windows API. Take for example a download URL code, instead of making our own code in our C+ program, we can make a call to the API.

In the **IMPORT Address Table**, under **SECTION .rdata**, we can see all the call to the Windows API the binary is doing. Some functions, like `ShellExecuteW` or `URLDownloadToFile`. Many of these functions can be used for good programs, as well as malware.

We can check the [MalAPI.io](https://malapi.io/) page to get an idea of some commonly Windows API functions are be using in malware.

# Packed Analysis

Packed malware is a kind of compression/encryption mechanism to make a piece of malware looks different from the original source. In a packed malware we can see a new value, **UPX0**:

![Untitled](/assets/img/notes/malware/Untitled%203.png)

The **Address Table** this time is really shorter compare to others.

![Untitled](/assets/img/notes/malware/Untitled%204.png)

We can see some weird functions like **LoadLibraryA** and **GetProcAddress**, that is telling us that maybe when this binary is running these functions are executed and get the rest of the API functions that is using, so we cannot see them here.

Now the different between the **Virtual Size** and the **Size of Raw Data** is huge.

# Combining Analysis Methods

We are gonna use [pestudio](https://www.winitor.com/download2). This automatize the early analysis by checking all we have done before.
