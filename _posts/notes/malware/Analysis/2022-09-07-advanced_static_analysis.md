---
title: Notes | Advanced Static Analysis
author: Zeropio
date: 2022-09-07
categories: [Notes, Malware]
tags: [malware]
permalink: /notes/malware/advanced-static-analysis
---

In this section we will be using decompilers and dissemblers. There are things that humans understand, **high level** (Python, C#…) and things that computers understand, **low level** (binary). There are a middle step. As we don’t want to work with 0 and 1, there are some functions that comes from this 0 and 1 (like **mov**, **jmp**, **xor**…), and from this it comes the different languages.

In **assembly** language, a malware will start in high level. From this human language a **compiler** will transfer them into bits, so the computer can understand it. **Assembly** is the human readable CPU instruction sets. They are the midterm between the compiler and the computer. 

We have the **CPU Instructions**. Assembly moves from right to left, for example the following line:

```nasm
mov edx,eax
```

It will start in **mov**, them it will move to **eax** and finally **edx**. The **jmp** instruction can be work with a **jnz**, that it is like a **if**. If the value in check by **jnz** it will jump to one value or other. The **sub** will subtract values. 

Then we have **push** and **pop**. This is how we interact with the **Stack**. The **Stack** is the place where we can hold information in the memory. The stack has addresses like `0xffffffff` , as the stack grows it grows the number (`0x000000`). If we need to set up variables from a function, we will **push** the values (like **0**, **string**,…). The **pop** will do the opposite, it will remove the lower information in the stack until the first one.

Then we have the **call** function. Everything start in the **main()** function. After doing what the binary do, it will return to the **main()** method. Inside this method, we can **call** a variable from the stack or a function from the program. Each call we do, it will save it in the last location in the **ebp**. So when we are done with the last call, we will return to the before. Until we reach the **main()** method.

And lastly, **Memory Registers**. Like for example **eax** (accumulator register), **edx** (data register), **ebx** (base register), **esp** (extended stack pointer), **ebp** (extended base pointer) and **eip** (extended instruction pointer).

In malware, when we are giving a malware probably the binary has a bunch of instruction for the computer, that we can try to make it human readable.

# Cutter

We will be using **Cutter** for this. Open it and select the malware sample. When it start, we should be seeing something like:

![Untitled](/assets/img/notes/malware/advanced-static/Untitled.png)

In the central panel we see some info that we should been able to gather at this point. But if we look on the left we found some entries. The first one, **entry0**, can be look at this:

![Untitled](/assets/img/notes/malware/advanced-static/Untitled%201.png)

This is assembly language. If we scroll down we should find a **main** entry. Here we can see the program functions.

![Untitled](/assets/img/notes/malware/advanced-static/Untitled%202.png)

This could be tricky to follow. If we search below, we can see a flow of the program. Take this as an example:

![Untitled](/assets/img/notes/malware/advanced-static/Untitled%203.png)

We see that the binary is checking something in the memory. Based on what it finds, it will jump into one part or another. See how the hex value is the same in each. If the content of the **eax** variable is not zero it will go through the green arrow. If not, it will go through the red arrow.

Lastly, we have the last option below, the **Decompiler**. This will try to make the assembly functions into code again.

# Detect Process Injection

It is common for malware to inject process into another process to be masked. There are some keys in assembly that can help us identifying it. Take the following **main** assembly code:

```nasm
;-- section..text:
159: int main (int32_t arg_ch);
; var LPCVOID lpBuffer @ ebp-0x14c
; var int32_t var_4h @ ebp-0x4
; arg int32_t arg_ch @ ebp+0xc
0x00401000      push    ebp        ; [00] -r-x section size 4096 named .text
0x00401001      mov     ebp, esp
0x00401003      sub     esp, 0x14c
0x00401009      .word 0x04a1
0x0040100b      xor     byte [eax], al
0x0040100e      xor     eax, ebp
0x00401010      mov     dword [var_4h], eax
0x00401013      mov     eax, dword [arg_ch]
0x00401016      mov     ecx, 0x51  ; 'Q' ; 81
0x0040101b      push    esi
0x0040101c      push    edi
0x0040101d      mov     esi, 0x402110
0x00401022      lea     edi, [lpBuffer]
0x00401028      push    dword [eax + 4] ; const char *str
0x0040102b      rep     movsd dword es:[edi], dword ptr [esi]
0x0040102d      movsb   byte es:[edi], byte ptr [esi]
0x0040102e      call    dword [atoi] ; 0x40205c ; int atoi(const char *str)
0x00401034      add     esp, 4
0x00401037      push    eax
0x00401038      push    0          ; BOOL bInheritHandle
0x0040103a      push    0x1fffff   ; DWORD dwDesiredAccess
0x0040103f      call    dword [OpenProcess] ; 0x402004 ; HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
0x00401045      push    0x40       ; '@' ; 64
0x00401047      push    0x3000
0x0040104c      push    0x145      ; 325
0x00401051      mov     edi, eax
0x00401053      push    0          ; LPVOID lpAddress
0x00401055      push    edi        ; HANDLE hProcess
0x00401056      call    dword [VirtualAllocEx] ; 0x40200c ; LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
0x0040105c      push    0          ; SIZE_T *lpNumberOfBytesWritten
0x0040105e      mov     esi, eax
0x00401060      lea     eax, [lpBuffer]
0x00401066      push    0x145      ; 325 ; SIZE_T nSize
0x0040106b      push    eax        ; LPCVOID lpBuffer
0x0040106c      push    esi        ; LPVOID lpBaseAddress
0x0040106d      push    edi        ; HANDLE hProcess
0x0040106e      call    dword [WriteProcessMemory] ; 0x402000 ; BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
0x00401074      push    0
0x00401076      push    0
0x00401078      push    0
0x0040107a      push    esi
0x0040107b      push    0
0x0040107d      push    0          ; LPSECURITY_ATTRIBUTES lpThreadAttributes
0x0040107f      push    edi        ; HANDLE hProcess
0x00401080      call    dword [CreateRemoteThread] ; 0x402010 ; HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
0x00401086      push    edi        ; HANDLE hObject
0x00401087      call    dword [CloseHandle] ; 0x402008 ; BOOL CloseHandle(HANDLE hObject)
0x0040108d      mov     ecx, dword [var_4h]
0x00401090      xor     eax, eax
0x00401092      pop     edi
0x00401093      xor     ecx, ebp
0x00401095      pop     esi
0x00401096      call    fcn.0040109f
0x0040109b      mov     esp, ebp
0x0040109d      pop     ebp
0x0040109e      ret
```

We see in the first lines an argument (**arg_ch**). We can see it here, the value of this argument is **eax**:

```nasm
;-- section..text:
159: int main (int32_t arg_ch);
...<SNIP>...
0x00401010      mov     dword [var_4h], eax
0x00401013      mov     eax, dword [arg_ch]
```

We see a call to a **dword**, that it is calling a process ID:

```nasm
0x0040103a      push    0x1fffff   ; DWORD dwDesiredAccess
0x0040103f      call    dword [OpenProcess] ; 0x402004 ; HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
```

Then pass the PID to the **edi**:

```nasm
0x00401051      mov     edi, eax
```

Until now, this program is giving a PID, it loads it into **eax**, uses it to open the specified process, and then take that PID and loads it into **edi**. This is for using it again, in the next lines:

```nasm
0x00401056      call    dword [VirtualAllocEx] ; 0x40200c ; LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
```

Here is giving the name of the PID to allocate the memory into that process. Below we have the following line:

```nasm
0x00401066      push    0x145      ; 325 ; SIZE_T nSize
0x0040106b      push    eax        ; LPCVOID lpBuffer
0x0040106c      push    esi        ; LPVOID lpBaseAddress
0x0040106d      push    edi        ; HANDLE hProcess
0x0040106e      call    dword [WriteProcessMemory] ; 0x402000 ; BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
```

Here the **edi** has the process handle (in **eax** we have the PID), the **esi** has the base address of this process and **eax** has the **lpBuffer**. To find the buffer we need to scroll up:

```nasm
;-- section..text:
159: int main (int32_t arg_ch);
; var LPCVOID lpBuffer @ ebp-0x14c
```

The next API call is going to be the end of this program of **CreateRemoteThread**.

```nasm
0x00401074      push    0
0x00401076      push    0
0x00401078      push    0
0x0040107a      push    esi
0x0040107b      push    0
0x0040107d      push    0          ; LPSECURITY_ATTRIBUTES lpThreadAttributes
0x0040107f      push    edi        ; HANDLE hProcess
0x00401080      call    dword [CreateRemoteThread] ; 0x402010 ; HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
```

This call only need two parameters. The first one is going to be the handle process (**edi**). Second, third and forth is going to be the start address, what means where this thread is going to execute (**esi**).

The flow will be:

1. It read a PID
2. Takes that PID and open that process with the access level required to write into that process (**0x0040103f**)
3. Allocate a section of memory with read, write and execute permissions (**0x00401056**)
4. Write the content of a specified variable into the allocate memory (**0x0040106e**)
5. Start a thread and tells the thread to go to a address (**0x00401080**)

This is a common way to make a shellcode. We generate it, inject it in a process and execute that process. If we take a look at the infected program we shold see in the **Memory** tab in **Properties** a memory with full access (RWX) like this one:

![Untitled](/assets/img/notes/malware/advanced-static/Untitled%204.png)
