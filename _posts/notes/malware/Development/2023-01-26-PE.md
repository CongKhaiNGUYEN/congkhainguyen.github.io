---
title: Notes | Portable Executable
author: Zeropio
date: 2023-01-26
categories: [Notes, Malware]
tags: [malware]
permalink: /notes/malware/portable-executable
---

**PE** (**Portable Executable**) it is a way to stored a file in the disk, so the Windows loader can read it and execute it. PE file are formed by the **headers** and **sections** (in a short brief). This is the structure of a PE by [Corkami](https://github.com/corkami):

![Untitled](/assets/img/notes/malware/development/pe101.png)

There are three important sections for malware development `.text`, `.data`, and `.rsrc` (*resources*). Tools as [PE-Bear](https://github.com/hasherezade/pe-bear-releases) or the built-in function `dumpbin` from Visual Studio:
```console
PS C:\Users\Zeropio> dumpbin /headers C:\Windows\System32\calc.exe
```

Code can be compiled into EXE or DLL. EXE files are independent program which can be loaded into memory as an independent process. DLL (*Dynamic Link Library*) are PE modules that are loaded into another process and cannot be loaded independent into memory.

The main difference is that in the EXE we need to have a **main** function in the code. For the DLL the loader has already create a process and memory and just need the DLL to implement a function or functions. To implement malware as a DLL we need to implement a **dllmain** and export at least one function.

---

# Creation

## EXE

First we need a C file, as the following **.cpp**:
```cpp
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
	
	printf("RTO OST!\n");
	
	getchar();
	
	return 0;
}
```

For compile it, we can use the *x64 Native Tools Command Prompt for VS* (or *x86* for 64 bits):
```console
C:\Users\Zeropio>cl.exe /nologo /Ox /MT /W0 /GS- /DNDEBUG /Tc<FILE>.cpp /link /OUT:<NAME>.exe /SUBSYSTEM:CONSOLE /MACHINE:x64
```

The flags are:
| **Flag** | **Description** |
| -------- | --------------- |
| `/nologo` | Don't display banner |
| `/Ox` | Optimization for speed |
| `/MT` | Multithreaded executable |
| `/W0` | Warning levels to 0 (suppressed) |
| `/GS-` | Check buffer security |
| `/DNDEBUG` | Disable assertions | 
| `/Tc<file>` | Specified C file |
| `/link` | Passed the specified option to link |

Just executing the line or doing it in a **bat** file will create the binary. We can inspect the file in **Resource Hacker**. For this PE we can see the following libraries being used:
- `apphelp.dll`
- `kernel32.dll`
- `kernelBase.dll`
- `locale.nls`
- `ntdll.dll`

Which are standard for these type of files.

## DLL

For a DLL executable we need first to initialize the DLL, as the `main` function in an EXE:
```cpp
#include <windows.h>
#pragma comment (lib, "user32.lib")

BOOL APIENTRY DLLMain (HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
	
	switch (ul_reason_for_call) {
		case DLL_PROCESS_ATTACH:
		case DLL_PROCESS_DETACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
			break;
	}
	return TRUE;
}
```

Then we create a function that can be call later in another program:
```cpp
extern "C" {
__declspec(dllexport) BOOL WINAPI MyFunction(void) {
	
	MessageBox(
		NULL,
		"RTO",
		"OST",
		MB_OK
	);
	
		return TRUE;
	}
}

```

We can now compile it with the following command:
```console
C:\Users\Zeropio>cl.exe /D_USRDLL /D_WINDLL <FILE>.cpp /MT /link /DLL /OUT:<NAME>.dll
```

DLLs need to be attach to an EXE to work, but we can test it with:
```console
C:\Users\Zeropio>rundll32 implant.dll,<FUNCTION>
```





